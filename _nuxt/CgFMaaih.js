import{R as Fe}from"./jYV8uuws.js";import{f as be,t as Le,w as Be,r as he,l as Ne,N as Ae}from"./jmR2vRPQ.js";import{f as qe,j as De}from"./DlQCJ7AR.js";import{t as te}from"./ejpV0U7u.js";import{F as ke,S as ee,v as We,R as Pe,w as Ve,x as _e,y as Ue}from"./BzSfo5GL.js";import Ge from"./Bmodg22F.js";import{L as ze}from"./DgWwiSy2.js";let q=0;const k=1<<q++,d=1<<q++,_=1<<q++,R=1<<q++,N=1<<q++,G=1<<q++,x=Math.pow(2,q)-1,le={[k]:"boolean",[d]:"number",[_]:"string",[R]:"color",[N]:"number[]",[G]:"size"},je=Object.keys(le).map(Number).sort(qe);function Se(t){return t in le}function z(t){const e=[];for(const r of je)j(t,r)&&e.push(le[r]);return e.length===0?"untyped":e.length<3?e.join(" or "):e.slice(0,-1).join(", ")+", or "+e[e.length-1]}function j(t,e){return(t&e)===e}function B(t,e){return t===e}class b{constructor(e,r){if(!Se(e))throw new Error(`literal expressions must have a specific type, got ${z(e)}`);this.type=e,this.value=r}}class Xe{constructor(e,r,...i){this.type=e,this.operator=r,this.args=i}}function Te(){return{variables:new Set,properties:new Set,featureId:!1,geometryType:!1,mapState:!1}}function A(t,e,r){switch(typeof t){case"boolean":{if(B(e,_))return new b(_,t?"true":"false");if(!j(e,k))throw new Error(`got a boolean, but expected ${z(e)}`);return new b(k,t)}case"number":{if(B(e,G))return new b(G,te(t));if(B(e,k))return new b(k,!!t);if(B(e,_))return new b(_,t.toString());if(!j(e,d))throw new Error(`got a number, but expected ${z(e)}`);return new b(d,t)}case"string":{if(B(e,R))return new b(R,be(t));if(B(e,k))return new b(k,!!t);if(!j(e,_))throw new Error(`got a string, but expected ${z(e)}`);return new b(_,t)}}if(!Array.isArray(t))throw new Error("expression must be an array or a primitive value");if(t.length===0)throw new Error("empty expression");if(typeof t[0]=="string")return nt(t,e,r);for(const i of t)if(typeof i!="number")throw new Error("expected an array of numbers");if(B(e,G)){if(t.length!==2)throw new Error(`expected an array of two values for a size, got ${t.length}`);return new b(G,t)}if(B(e,R)){if(t.length===3)return new b(R,[...t,1]);if(t.length===4)return new b(R,t);throw new Error(`expected an array of 3 or 4 values for a color, got ${t.length}`)}if(!j(e,N))throw new Error(`got an array of numbers, but expected ${z(e)}`);return new b(N,t)}const a={Get:"get",Var:"var",Concat:"concat",GeometryType:"geometry-type",LineMetric:"line-metric",Any:"any",All:"all",Not:"!",Resolution:"resolution",Zoom:"zoom",Time:"time",Equal:"==",NotEqual:"!=",GreaterThan:">",GreaterThanOrEqualTo:">=",LessThan:"<",LessThanOrEqualTo:"<=",Multiply:"*",Divide:"/",Add:"+",Subtract:"-",Clamp:"clamp",Mod:"%",Pow:"^",Abs:"abs",Floor:"floor",Ceil:"ceil",Round:"round",Sin:"sin",Cos:"cos",Atan:"atan",Sqrt:"sqrt",Match:"match",Between:"between",Interpolate:"interpolate",Coalesce:"coalesce",Case:"case",In:"in",Number:"number",String:"string",Array:"array",Color:"color",Id:"id",Band:"band",Palette:"palette",ToString:"to-string",Has:"has"},Ye={[a.Get]:h(g(1,1/0),ge),[a.Var]:h(g(1,1),Je),[a.Has]:h(g(1,1/0),ge),[a.Id]:h(He,V),[a.Concat]:h(g(2,1/0),m(_)),[a.GeometryType]:h(Ke,V),[a.LineMetric]:h(V),[a.Resolution]:h(se,V),[a.Zoom]:h(se,V),[a.Time]:h(se,V),[a.Any]:h(g(2,1/0),m(k)),[a.All]:h(g(2,1/0),m(k)),[a.Not]:h(g(1,1),m(k)),[a.Equal]:h(g(2,2),m(x)),[a.NotEqual]:h(g(2,2),m(x)),[a.GreaterThan]:h(g(2,2),m(d)),[a.GreaterThanOrEqualTo]:h(g(2,2),m(d)),[a.LessThan]:h(g(2,2),m(d)),[a.LessThanOrEqualTo]:h(g(2,2),m(d)),[a.Multiply]:h(g(2,1/0),de),[a.Coalesce]:h(g(2,1/0),de),[a.Divide]:h(g(2,2),m(d)),[a.Add]:h(g(2,1/0),m(d)),[a.Subtract]:h(g(2,2),m(d)),[a.Clamp]:h(g(3,3),m(d)),[a.Mod]:h(g(2,2),m(d)),[a.Pow]:h(g(2,2),m(d)),[a.Abs]:h(g(1,1),m(d)),[a.Floor]:h(g(1,1),m(d)),[a.Ceil]:h(g(1,1),m(d)),[a.Round]:h(g(1,1),m(d)),[a.Sin]:h(g(1,1),m(d)),[a.Cos]:h(g(1,1),m(d)),[a.Atan]:h(g(1,2),m(d)),[a.Sqrt]:h(g(1,1),m(d)),[a.Match]:h(g(4,1/0),pe,Qe),[a.Between]:h(g(3,3),m(d)),[a.Interpolate]:h(g(6,1/0),pe,xe),[a.Case]:h(g(3,1/0),Ze,et),[a.In]:h(g(2,2),tt),[a.Number]:h(g(1,1/0),m(x)),[a.String]:h(g(1,1/0),m(x)),[a.Array]:h(g(1,1/0),m(d)),[a.Color]:h(g(1,4),m(d)),[a.Band]:h(g(1,3),m(d)),[a.Palette]:h(g(2,2),rt),[a.ToString]:h(g(1,1),m(k|d|_|R))};function ge(t,e,r){const i=t.length-1,o=new Array(i);for(let n=0;n<i;++n){const s=t[n+1];switch(typeof s){case"number":{o[n]=new b(d,s);break}case"string":{o[n]=new b(_,s);break}default:throw new Error(`expected a string key or numeric array index for a get operation, got ${s}`)}n===0&&r.properties.add(String(s))}return o}function Je(t,e,r){const i=t[1];if(typeof i!="string")throw new Error("expected a string argument for var operation");return r.variables.add(i),[new b(_,i)]}function He(t,e,r){r.featureId=!0}function Ke(t,e,r){r.geometryType=!0}function se(t,e,r){r.mapState=!0}function V(t,e,r){const i=t[0];if(t.length!==1)throw new Error(`expected no arguments for ${i} operation`);return[]}function g(t,e){return function(r,i,o){const n=r[0],s=r.length-1;if(t===e){if(s!==t){const u=t===1?"":"s";throw new Error(`expected ${t} argument${u} for ${n}, got ${s}`)}}else if(s<t||s>e){const u=e===1/0?`${t} or more`:`${t} to ${e}`;throw new Error(`expected ${u} arguments for ${n}, got ${s}`)}}}function de(t,e,r){const i=t.length-1,o=new Array(i);for(let n=0;n<i;++n){const s=A(t[n+1],e,r);o[n]=s}return o}function m(t){return function(e,r,i){const o=e.length-1,n=new Array(o);for(let s=0;s<o;++s){const u=A(e[s+1],t,i);n[s]=u}return n}}function Ze(t,e,r){const i=t[0],o=t.length-1;if(o%2===0)throw new Error(`expected an odd number of arguments for ${i}, got ${o} instead`)}function pe(t,e,r){const i=t[0],o=t.length-1;if(o%2===1)throw new Error(`expected an even number of arguments for operation ${i}, got ${o} instead`)}function Qe(t,e,r){const i=t.length-1,o=_|d|k,n=A(t[1],o,r),s=A(t[t.length-1],e,r),u=new Array(i-2);for(let l=0;l<i-2;l+=2){try{const c=A(t[l+2],n.type,r);u[l]=c}catch(c){throw new Error(`failed to parse argument ${l+1} of match expression: ${c.message}`)}try{const c=A(t[l+3],s.type,r);u[l+1]=c}catch(c){throw new Error(`failed to parse argument ${l+2} of match expression: ${c.message}`)}}return[n,...u,s]}function xe(t,e,r){const i=t[1];let o;switch(i[0]){case"linear":o=1;break;case"exponential":const l=i[1];if(typeof l!="number"||l<=0)throw new Error(`expected a number base for exponential interpolation, got ${JSON.stringify(l)} instead`);o=l;break;default:throw new Error(`invalid interpolation type: ${JSON.stringify(i)}`)}const n=new b(d,o);let s;try{s=A(t[2],d,r)}catch(l){throw new Error(`failed to parse argument 1 in interpolate expression: ${l.message}`)}const u=new Array(t.length-3);for(let l=0;l<u.length;l+=2){try{const c=A(t[l+3],d,r);u[l]=c}catch(c){throw new Error(`failed to parse argument ${l+2} for interpolate expression: ${c.message}`)}try{const c=A(t[l+4],e,r);u[l+1]=c}catch(c){throw new Error(`failed to parse argument ${l+3} for interpolate expression: ${c.message}`)}}return[n,s,...u]}function et(t,e,r){const i=A(t[t.length-1],e,r),o=new Array(t.length-1);for(let n=0;n<o.length-1;n+=2){try{const s=A(t[n+1],k,r);o[n]=s}catch(s){throw new Error(`failed to parse argument ${n} of case expression: ${s.message}`)}try{const s=A(t[n+2],i.type,r);o[n+1]=s}catch(s){throw new Error(`failed to parse argument ${n+1} of case expression: ${s.message}`)}}return o[o.length-1]=i,o}function tt(t,e,r){let i=t[2];if(!Array.isArray(i))throw new Error('the second argument for the "in" operator must be an array');let o;if(typeof i[0]=="string"){if(i[0]!=="literal")throw new Error('for the "in" operator, a string array should be wrapped in a "literal" operator to disambiguate from expressions');if(!Array.isArray(i[1]))throw new Error('failed to parse "in" expression: the literal operator must be followed by an array');i=i[1],o=_}else o=d;const n=new Array(i.length);for(let u=0;u<n.length;u++)try{const l=A(i[u],o,r);n[u]=l}catch(l){throw new Error(`failed to parse haystack item ${u} for "in" expression: ${l.message}`)}return[A(t[1],o,r),...n]}function rt(t,e,r){let i;try{i=A(t[1],d,r)}catch(s){throw new Error(`failed to parse first argument in palette expression: ${s.message}`)}const o=t[2];if(!Array.isArray(o))throw new Error("the second argument of palette must be an array");const n=new Array(o.length);for(let s=0;s<n.length;s++){let u;try{u=A(o[s],R,r)}catch(l){throw new Error(`failed to parse color at index ${s} in palette expression: ${l.message}`)}if(!(u instanceof b))throw new Error(`the palette color at index ${s} must be a literal value`);n[s]=u}return[i,...n]}function h(...t){return function(e,r,i){const o=e[0];let n;for(let s=0;s<t.length;s++){const u=t[s](e,r,i);if(s==t.length-1){if(!u)throw new Error("expected last argument validator to return the parsed args");n=u}}return new Xe(r,o,...n)}}function nt(t,e,r){const i=t[0],o=Ye[i];if(!o)throw new Error(`unknown operator: ${i}`);return o(t,e,r)}function $e(t){if(!t)return"";const e=t.getType();switch(e){case"Point":case"LineString":case"Polygon":return e;case"MultiPoint":case"MultiLineString":case"MultiPolygon":return e.substring(5);case"Circle":return"Polygon";case"GeometryCollection":return $e(t.getGeometries()[0]);default:return""}}function Ce(){return{variables:{},properties:{},resolution:NaN,featureId:null,geometryType:""}}function F(t,e,r){const i=A(t,e,r);return I(i)}function I(t,e){if(t instanceof b){if(t.type===R&&typeof t.value=="string"){const i=be(t.value);return function(){return i}}return function(){return t.value}}const r=t.operator;switch(r){case a.Number:case a.String:case a.Coalesce:return ot(t);case a.Get:case a.Var:case a.Has:return it(t);case a.Id:return i=>i.featureId;case a.GeometryType:return i=>i.geometryType;case a.Concat:{const i=t.args.map(o=>I(o));return o=>"".concat(...i.map(n=>n(o).toString()))}case a.Resolution:return i=>i.resolution;case a.Any:case a.All:case a.Between:case a.In:case a.Not:return at(t);case a.Equal:case a.NotEqual:case a.LessThan:case a.LessThanOrEqualTo:case a.GreaterThan:case a.GreaterThanOrEqualTo:return st(t);case a.Multiply:case a.Divide:case a.Add:case a.Subtract:case a.Clamp:case a.Mod:case a.Pow:case a.Abs:case a.Floor:case a.Ceil:case a.Round:case a.Sin:case a.Cos:case a.Atan:case a.Sqrt:return ut(t);case a.Case:return lt(t);case a.Match:return ct(t);case a.Interpolate:return ft(t);case a.ToString:return ht(t);default:throw new Error(`Unsupported operator ${r}`)}}function ot(t,e){const r=t.operator,i=t.args.length,o=new Array(i);for(let n=0;n<i;++n)o[n]=I(t.args[n]);switch(r){case a.Coalesce:return n=>{for(let s=0;s<i;++s){const u=o[s](n);if(typeof u<"u"&&u!==null)return u}throw new Error("Expected one of the values to be non-null")};case a.Number:case a.String:return n=>{for(let s=0;s<i;++s){const u=o[s](n);if(typeof u===r)return u}throw new Error(`Expected one of the values to be a ${r}`)};default:throw new Error(`Unsupported assertion operator ${r}`)}}function it(t,e){const i=t.args[0].value;switch(t.operator){case a.Get:return o=>{const n=t.args;let s=o.properties[i];for(let u=1,l=n.length;u<l;++u){const f=n[u].value;s=s[f]}return s};case a.Var:return o=>o.variables[i];case a.Has:return o=>{const n=t.args;if(!(i in o.properties))return!1;let s=o.properties[i];for(let u=1,l=n.length;u<l;++u){const f=n[u].value;if(!s||!Object.hasOwn(s,f))return!1;s=s[f]}return!0};default:throw new Error(`Unsupported accessor operator ${t.operator}`)}}function st(t,e){const r=t.operator,i=I(t.args[0]),o=I(t.args[1]);switch(r){case a.Equal:return n=>i(n)===o(n);case a.NotEqual:return n=>i(n)!==o(n);case a.LessThan:return n=>i(n)<o(n);case a.LessThanOrEqualTo:return n=>i(n)<=o(n);case a.GreaterThan:return n=>i(n)>o(n);case a.GreaterThanOrEqualTo:return n=>i(n)>=o(n);default:throw new Error(`Unsupported comparison operator ${r}`)}}function at(t,e){const r=t.operator,i=t.args.length,o=new Array(i);for(let n=0;n<i;++n)o[n]=I(t.args[n]);switch(r){case a.Any:return n=>{for(let s=0;s<i;++s)if(o[s](n))return!0;return!1};case a.All:return n=>{for(let s=0;s<i;++s)if(!o[s](n))return!1;return!0};case a.Between:return n=>{const s=o[0](n),u=o[1](n),l=o[2](n);return s>=u&&s<=l};case a.In:return n=>{const s=o[0](n);for(let u=1;u<i;++u)if(s===o[u](n))return!0;return!1};case a.Not:return n=>!o[0](n);default:throw new Error(`Unsupported logical operator ${r}`)}}function ut(t,e){const r=t.operator,i=t.args.length,o=new Array(i);for(let n=0;n<i;++n)o[n]=I(t.args[n]);switch(r){case a.Multiply:return n=>{let s=1;for(let u=0;u<i;++u)s*=o[u](n);return s};case a.Divide:return n=>o[0](n)/o[1](n);case a.Add:return n=>{let s=0;for(let u=0;u<i;++u)s+=o[u](n);return s};case a.Subtract:return n=>o[0](n)-o[1](n);case a.Clamp:return n=>{const s=o[0](n),u=o[1](n);if(s<u)return u;const l=o[2](n);return s>l?l:s};case a.Mod:return n=>o[0](n)%o[1](n);case a.Pow:return n=>Math.pow(o[0](n),o[1](n));case a.Abs:return n=>Math.abs(o[0](n));case a.Floor:return n=>Math.floor(o[0](n));case a.Ceil:return n=>Math.ceil(o[0](n));case a.Round:return n=>Math.round(o[0](n));case a.Sin:return n=>Math.sin(o[0](n));case a.Cos:return n=>Math.cos(o[0](n));case a.Atan:return i===2?n=>Math.atan2(o[0](n),o[1](n)):n=>Math.atan(o[0](n));case a.Sqrt:return n=>Math.sqrt(o[0](n));default:throw new Error(`Unsupported numeric operator ${r}`)}}function lt(t,e){const r=t.args.length,i=new Array(r);for(let o=0;o<r;++o)i[o]=I(t.args[o]);return o=>{for(let n=0;n<r-1;n+=2)if(i[n](o))return i[n+1](o);return i[r-1](o)}}function ct(t,e){const r=t.args.length,i=new Array(r);for(let o=0;o<r;++o)i[o]=I(t.args[o]);return o=>{const n=i[0](o);for(let s=1;s<r-1;s+=2)if(n===i[s](o))return i[s+1](o);return i[r-1](o)}}function ft(t,e){const r=t.args.length,i=new Array(r);for(let o=0;o<r;++o)i[o]=I(t.args[o]);return o=>{const n=i[0](o),s=i[1](o);let u,l;for(let c=2;c<r;c+=2){const f=i[c](o);let p=i[c+1](o);const w=Array.isArray(p);if(w&&(p=Be(p)),f>=s)return c===2?p:w?gt(n,s,u,l,f,p):S(n,s,u,l,f,p);u=f,l=p}return l}}function ht(t,e){const r=t.operator,i=t.args.length,o=new Array(i);for(let n=0;n<i;++n)o[n]=I(t.args[n]);switch(r){case a.ToString:return n=>{const s=o[0](n);return t.args[0].type===R?Le(s):s.toString()};default:throw new Error(`Unsupported convert operator ${r}`)}}function S(t,e,r,i,o,n){const s=o-r;if(s===0)return i;const u=e-r,l=t===1?u/s:(Math.pow(t,u)-1)/(Math.pow(t,s)-1);return i+l*(n-i)}function gt(t,e,r,i,o,n){if(o-r===0)return i;const u=he(i),l=he(n);let c=l[2]-u[2];c>180?c-=360:c<-180&&(c+=360);const f=[S(t,e,r,u[0],o,l[0]),S(t,e,r,u[1],o,l[1]),u[2]+S(t,e,r,0,o,c),S(t,e,r,i[3],o,n[3])];return Ne(f)}const dt="#333";class ce{constructor(e){e=e||{},this.font_=e.font,this.rotation_=e.rotation,this.rotateWithView_=e.rotateWithView,this.keepUpright_=e.keepUpright,this.scale_=e.scale,this.scaleArray_=te(e.scale!==void 0?e.scale:1),this.text_=e.text,this.textAlign_=e.textAlign,this.justify_=e.justify,this.repeat_=e.repeat,this.textBaseline_=e.textBaseline,this.fill_=e.fill!==void 0?e.fill:new ke({color:dt}),this.maxAngle_=e.maxAngle!==void 0?e.maxAngle:Math.PI/4,this.placement_=e.placement!==void 0?e.placement:"point",this.overflow_=!!e.overflow,this.stroke_=e.stroke!==void 0?e.stroke:null,this.offsetX_=e.offsetX!==void 0?e.offsetX:0,this.offsetY_=e.offsetY!==void 0?e.offsetY:0,this.backgroundFill_=e.backgroundFill?e.backgroundFill:null,this.backgroundStroke_=e.backgroundStroke?e.backgroundStroke:null,this.padding_=e.padding===void 0?null:e.padding,this.declutterMode_=e.declutterMode}clone(){const e=this.getScale();return new ce({font:this.getFont(),placement:this.getPlacement(),repeat:this.getRepeat(),maxAngle:this.getMaxAngle(),overflow:this.getOverflow(),rotation:this.getRotation(),rotateWithView:this.getRotateWithView(),keepUpright:this.getKeepUpright(),scale:Array.isArray(e)?e.slice():e,text:this.getText(),textAlign:this.getTextAlign(),justify:this.getJustify(),textBaseline:this.getTextBaseline(),fill:this.getFill()?this.getFill().clone():void 0,stroke:this.getStroke()?this.getStroke().clone():void 0,offsetX:this.getOffsetX(),offsetY:this.getOffsetY(),backgroundFill:this.getBackgroundFill()?this.getBackgroundFill().clone():void 0,backgroundStroke:this.getBackgroundStroke()?this.getBackgroundStroke().clone():void 0,padding:this.getPadding()||void 0,declutterMode:this.getDeclutterMode()})}getOverflow(){return this.overflow_}getFont(){return this.font_}getMaxAngle(){return this.maxAngle_}getPlacement(){return this.placement_}getRepeat(){return this.repeat_}getOffsetX(){return this.offsetX_}getOffsetY(){return this.offsetY_}getFill(){return this.fill_}getRotateWithView(){return this.rotateWithView_}getKeepUpright(){return this.keepUpright_}getRotation(){return this.rotation_}getScale(){return this.scale_}getScaleArray(){return this.scaleArray_}getStroke(){return this.stroke_}getText(){return this.text_}getTextAlign(){return this.textAlign_}getJustify(){return this.justify_}getTextBaseline(){return this.textBaseline_}getBackgroundFill(){return this.backgroundFill_}getBackgroundStroke(){return this.backgroundStroke_}getPadding(){return this.padding_}getDeclutterMode(){return this.declutterMode_}setOverflow(e){this.overflow_=e}setFont(e){this.font_=e}setMaxAngle(e){this.maxAngle_=e}setOffsetX(e){this.offsetX_=e}setOffsetY(e){this.offsetY_=e}setPlacement(e){this.placement_=e}setRepeat(e){this.repeat_=e}setRotateWithView(e){this.rotateWithView_=e}setKeepUpright(e){this.keepUpright_=e}setFill(e){this.fill_=e}setRotation(e){this.rotation_=e}setScale(e){this.scale_=e,this.scaleArray_=te(e!==void 0?e:1)}setStroke(e){this.stroke_=e}setText(e){this.text_=e}setTextAlign(e){this.textAlign_=e}setJustify(e){this.justify_=e}setTextBaseline(e){this.textBaseline_=e}setBackgroundFill(e){this.backgroundFill_=e}setBackgroundStroke(e){this.backgroundStroke_=e}setPadding(e){this.padding_=e}}function pt(t){return!0}function wt(t){const e=Te(),r=mt(t,e),i=Ce();return function(o,n){if(i.properties=o.getPropertiesInternal(),i.resolution=n,e.featureId){const s=o.getId();s!==void 0?i.featureId=s:i.featureId=null}return e.geometryType&&(i.geometryType=$e(o.getGeometry())),r(i)}}function we(t){const e=Te(),r=t.length,i=new Array(r);for(let s=0;s<r;++s)i[s]=ae(t[s],e);const o=Ce(),n=new Array(r);return function(s,u){if(o.properties=s.getPropertiesInternal(),o.resolution=u,e.featureId){const c=s.getId();c!==void 0?o.featureId=c:o.featureId=null}let l=0;for(let c=0;c<r;++c){const f=i[c](o);f&&(n[l]=f,l+=1)}return n.length=l,n}}function mt(t,e){const r=t.length,i=new Array(r);for(let o=0;o<r;++o){const n=t[o],s="filter"in n?F(n.filter,k,e):pt;let u;if(Array.isArray(n.style)){const l=n.style.length;u=new Array(l);for(let c=0;c<l;++c)u[c]=ae(n.style[c],e)}else u=[ae(n.style,e)];i[o]={filter:s,styles:u}}return function(o){const n=[];let s=!1;for(let u=0;u<r;++u){const l=i[u].filter;if(l(o)&&!(t[u].else&&s)){s=!0;for(const c of i[u].styles){const f=c(o);f&&n.push(f)}}}return n}}function ae(t,e){const r=X(t,"",e),i=Y(t,"",e),o=Et(t,e),n=yt(t,e),s=T(t,"z-index",e);if(!r&&!i&&!o&&!n&&!De(t))throw new Error("No fill, stroke, point, or text symbolizer properties in style: "+JSON.stringify(t));const u=new ee;return function(l){let c=!0;if(r){const f=r(l);f&&(c=!1),u.setFill(f)}if(i){const f=i(l);f&&(c=!1),u.setStroke(f)}if(o){const f=o(l);f&&(c=!1),u.setText(f)}if(n){const f=n(l);f&&(c=!1),u.setImage(f)}return s&&u.setZIndex(s(l)),c?null:u}}function X(t,e,r){let i;if(e+"fill-pattern-src"in t)i=kt(t,e+"fill-",r);else{if(t[e+"fill-color"]==="none")return n=>null;i=fe(t,e+"fill-color",r)}if(!i)return null;const o=new ke;return function(n){const s=i(n);return s===Ae?null:(o.setColor(s),o)}}function Y(t,e,r){const i=T(t,e+"stroke-width",r),o=fe(t,e+"stroke-color",r);if(!i&&!o)return null;const n=M(t,e+"stroke-line-cap",r),s=M(t,e+"stroke-line-join",r),u=Re(t,e+"stroke-line-dash",r),l=T(t,e+"stroke-line-dash-offset",r),c=T(t,e+"stroke-miter-limit",r),f=new We;return function(p){if(o){const w=o(p);if(w===Ae)return null;f.setColor(w)}if(i&&f.setWidth(i(p)),n){const w=n(p);if(w!=="butt"&&w!=="round"&&w!=="square")throw new Error("Expected butt, round, or square line cap");f.setLineCap(w)}if(s){const w=s(p);if(w!=="bevel"&&w!=="round"&&w!=="miter")throw new Error("Expected bevel, round, or miter line join");f.setLineJoin(w)}return u&&f.setLineDash(u(p)),l&&f.setLineDashOffset(l(p)),c&&f.setMiterLimit(c(p)),f}}function Et(t,e){const r="text-",i=M(t,r+"value",e);if(!i)return null;const o=X(t,r,e),n=X(t,r+"background-",e),s=Y(t,r,e),u=Y(t,r+"background-",e),l=M(t,r+"font",e),c=T(t,r+"max-angle",e),f=T(t,r+"offset-x",e),p=T(t,r+"offset-y",e),w=U(t,r+"overflow",e),D=M(t,r+"placement",e),W=T(t,r+"repeat",e),P=oe(t,r+"scale",e),$=U(t,r+"rotate-with-view",e),C=T(t,r+"rotation",e),H=M(t,r+"align",e),K=M(t,r+"justify",e),Z=M(t,r+"baseline",e),Q=U(t,r+"keep-upright",e),O=Re(t,r+"padding",e),L=ie(t,r+"declutter-mode"),y=new ce({declutterMode:L});return function(v){if(y.setText(i(v)),o&&y.setFill(o(v)),n&&y.setBackgroundFill(n(v)),s&&y.setStroke(s(v)),u&&y.setBackgroundStroke(u(v)),l&&y.setFont(l(v)),c&&y.setMaxAngle(c(v)),f&&y.setOffsetX(f(v)),p&&y.setOffsetY(p(v)),w&&y.setOverflow(w(v)),D){const E=D(v);if(E!=="point"&&E!=="line")throw new Error("Expected point or line for text-placement");y.setPlacement(E)}if(W&&y.setRepeat(W(v)),P&&y.setScale(P(v)),$&&y.setRotateWithView($(v)),C&&y.setRotation(C(v)),H){const E=H(v);if(E!=="left"&&E!=="center"&&E!=="right"&&E!=="end"&&E!=="start")throw new Error("Expected left, right, center, start, or end for text-align");y.setTextAlign(E)}if(K){const E=K(v);if(E!=="left"&&E!=="right"&&E!=="center")throw new Error("Expected left, right, or center for text-justify");y.setJustify(E)}if(Z){const E=Z(v);if(E!=="bottom"&&E!=="top"&&E!=="middle"&&E!=="alphabetic"&&E!=="hanging")throw new Error("Expected bottom, top, middle, alphabetic, or hanging for text-baseline");y.setTextBaseline(E)}return O&&y.setPadding(O(v)),Q&&y.setKeepUpright(Q(v)),y}}function yt(t,e){return"icon-src"in t?vt(t,e):"shape-points"in t?bt(t,e):"circle-radius"in t?At(t,e):null}function vt(t,e){const r="icon-",i=r+"src",o=Ie(t[i],i),n=re(t,r+"anchor",e),s=oe(t,r+"scale",e),u=T(t,r+"opacity",e),l=re(t,r+"displacement",e),c=T(t,r+"rotation",e),f=U(t,r+"rotate-with-view",e),p=Ee(t,r+"anchor-origin"),w=ye(t,r+"anchor-x-units"),D=ye(t,r+"anchor-y-units"),W=Ct(t,r+"color"),P=Tt(t,r+"cross-origin"),$=$t(t,r+"offset"),C=Ee(t,r+"offset-origin"),H=ne(t,r+"width"),K=ne(t,r+"height"),Z=_t(t,r+"size"),Q=ie(t,r+"declutter-mode"),O=new Ge({src:o,anchorOrigin:p,anchorXUnits:w,anchorYUnits:D,color:W,crossOrigin:P,offset:$,offsetOrigin:C,height:K,width:H,size:Z,declutterMode:Q});return function(L){return u&&O.setOpacity(u(L)),l&&O.setDisplacement(l(L)),c&&O.setRotation(c(L)),f&&O.setRotateWithView(f(L)),s&&O.setScale(s(L)),n&&O.setAnchor(n(L)),O}}function bt(t,e){const r="shape-",i=r+"points",o=r+"radius",n=ue(t[i],i),s=ue(t[o],o),u=X(t,r,e),l=Y(t,r,e),c=oe(t,r+"scale",e),f=re(t,r+"displacement",e),p=T(t,r+"rotation",e),w=U(t,r+"rotate-with-view",e),D=ne(t,r+"radius2"),W=ne(t,r+"angle"),P=ie(t,r+"declutter-mode"),$=new Pe({points:n,radius:s,radius2:D,angle:W,declutterMode:P});return function(C){return u&&$.setFill(u(C)),l&&$.setStroke(l(C)),f&&$.setDisplacement(f(C)),p&&$.setRotation(p(C)),w&&$.setRotateWithView(w(C)),c&&$.setScale(c(C)),$}}function At(t,e){const r="circle-",i=X(t,r,e),o=Y(t,r,e),n=T(t,r+"radius",e),s=oe(t,r+"scale",e),u=re(t,r+"displacement",e),l=T(t,r+"rotation",e),c=U(t,r+"rotate-with-view",e),f=ie(t,r+"declutter-mode"),p=new Ve({radius:5,declutterMode:f});return function(w){return n&&p.setRadius(n(w)),i&&p.setFill(i(w)),o&&p.setStroke(o(w)),u&&p.setDisplacement(u(w)),l&&p.setRotation(l(w)),c&&p.setRotateWithView(c(w)),s&&p.setScale(s(w)),p}}function T(t,e,r){if(!(e in t))return;const i=F(t[e],d,r);return function(o){return ue(i(o),e)}}function M(t,e,r){if(!(e in t))return null;const i=F(t[e],_,r);return function(o){return Ie(i(o),e)}}function kt(t,e,r){const i=M(t,e+"pattern-src",r),o=me(t,e+"pattern-offset",r),n=me(t,e+"pattern-size",r),s=fe(t,e+"color",r);return function(u){return{src:i(u),offset:o&&o(u),size:n&&n(u),color:s&&s(u)}}}function U(t,e,r){if(!(e in t))return null;const i=F(t[e],k,r);return function(o){const n=i(o);if(typeof n!="boolean")throw new Error(`Expected a boolean for ${e}`);return n}}function fe(t,e,r){if(!(e in t))return null;const i=F(t[e],R,r);return function(o){return Oe(i(o),e)}}function Re(t,e,r){if(!(e in t))return null;const i=F(t[e],N,r);return function(o){return J(i(o),e)}}function re(t,e,r){if(!(e in t))return null;const i=F(t[e],N,r);return function(o){const n=J(i(o),e);if(n.length!==2)throw new Error(`Expected two numbers for ${e}`);return n}}function me(t,e,r){if(!(e in t))return null;const i=F(t[e],N,r);return function(o){return Me(i(o),e)}}function oe(t,e,r){if(!(e in t))return null;const i=F(t[e],N|d,r);return function(o){return Rt(i(o),e)}}function ne(t,e){const r=t[e];if(r!==void 0){if(typeof r!="number")throw new Error(`Expected a number for ${e}`);return r}}function _t(t,e){const r=t[e];if(r!==void 0){if(typeof r=="number")return te(r);if(!Array.isArray(r))throw new Error(`Expected a number or size array for ${e}`);if(r.length!==2||typeof r[0]!="number"||typeof r[1]!="number")throw new Error(`Expected a number or size array for ${e}`);return r}}function Tt(t,e){const r=t[e];if(r!==void 0){if(typeof r!="string")throw new Error(`Expected a string for ${e}`);return r}}function Ee(t,e){const r=t[e];if(r!==void 0){if(r!=="bottom-left"&&r!=="bottom-right"&&r!=="top-left"&&r!=="top-right")throw new Error(`Expected bottom-left, bottom-right, top-left, or top-right for ${e}`);return r}}function ye(t,e){const r=t[e];if(r!==void 0){if(r!=="pixels"&&r!=="fraction")throw new Error(`Expected pixels or fraction for ${e}`);return r}}function $t(t,e){const r=t[e];if(r!==void 0)return J(r,e)}function ie(t,e){const r=t[e];if(r!==void 0){if(typeof r!="string")throw new Error(`Expected a string for ${e}`);if(r!=="declutter"&&r!=="obstacle"&&r!=="none")throw new Error(`Expected declutter, obstacle, or none for ${e}`);return r}}function Ct(t,e){const r=t[e];if(r!==void 0)return Oe(r,e)}function J(t,e){if(!Array.isArray(t))throw new Error(`Expected an array for ${e}`);const r=t.length;for(let i=0;i<r;++i)if(typeof t[i]!="number")throw new Error(`Expected an array of numbers for ${e}`);return t}function Ie(t,e){if(typeof t!="string")throw new Error(`Expected a string for ${e}`);return t}function ue(t,e){if(typeof t!="number")throw new Error(`Expected a number for ${e}`);return t}function Oe(t,e){if(typeof t=="string")return t;const r=J(t,e),i=r.length;if(i<3||i>4)throw new Error(`Expected a color with 3 or 4 values for ${e}`);return r}function Me(t,e){const r=J(t,e);if(r.length!==2)throw new Error(`Expected an array of two numbers for ${e}`);return r}function Rt(t,e){return typeof t=="number"?t:Me(t,e)}const ve={RENDER_ORDER:"renderOrder"};class Dt extends ze{constructor(e){e=e||{};const r=Object.assign({},e);delete r.style,delete r.renderBuffer,delete r.updateWhileAnimating,delete r.updateWhileInteracting,super(r),this.declutter_=e.declutter?String(e.declutter):void 0,this.renderBuffer_=e.renderBuffer!==void 0?e.renderBuffer:100,this.style_=null,this.styleFunction_=void 0,this.setStyle(e.style),this.updateWhileAnimating_=e.updateWhileAnimating!==void 0?e.updateWhileAnimating:!1,this.updateWhileInteracting_=e.updateWhileInteracting!==void 0?e.updateWhileInteracting:!1}getDeclutter(){return this.declutter_}getFeatures(e){return super.getFeatures(e)}getRenderBuffer(){return this.renderBuffer_}getRenderOrder(){return this.get(ve.RENDER_ORDER)}getStyle(){return this.style_}getStyleFunction(){return this.styleFunction_}getUpdateWhileAnimating(){return this.updateWhileAnimating_}getUpdateWhileInteracting(){return this.updateWhileInteracting_}renderDeclutter(e,r){const i=this.getDeclutter();i in e.declutter||(e.declutter[i]=new Fe(9)),this.getRenderer().renderDeclutter(e,r)}setRenderOrder(e){this.set(ve.RENDER_ORDER,e)}setStyle(e){this.style_=e===void 0?_e:e;const r=It(e);this.styleFunction_=e===null?void 0:Ue(r),this.changed()}setDeclutter(e){this.declutter_=e?String(e):void 0,this.changed()}}function It(t){if(t===void 0)return _e;if(!t)return null;if(typeof t=="function"||t instanceof ee)return t;if(!Array.isArray(t))return we([t]);if(t.length===0)return[];const e=t.length,r=t[0];if(r instanceof ee){const o=new Array(e);for(let n=0;n<e;++n){const s=t[n];if(!(s instanceof ee))throw new Error("Expected a list of style instances");o[n]=s}return o}if("style"in r){const o=new Array(e);for(let n=0;n<e;++n){const s=t[n];if(!("style"in s))throw new Error("Expected a list of rules with a style property");o[n]=s}return wt(o)}return we(t)}export{Dt as B};
