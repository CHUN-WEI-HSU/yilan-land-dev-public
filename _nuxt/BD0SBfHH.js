import{R as Mr}from"./jYV8uuws.js";import{f as yr,t as Nr,w as Lr,r as lr,l as qr,N as vr}from"./DYcbPNs3.js";import{d as Fr,h as Dr}from"./CBsAYBMq.js";import{t as br}from"./DSor2vHC.js";import{S as rr,R as Br,v as Gr,w as Ar,x as Wr}from"./BIaPAw8G.js";import Pr from"./MGqbFZfO.js";import zr from"./_zC-pxp2.js";import _r from"./DO_F0CpN.js";import Vr from"./WJtrQfu8.js";import{L as Ur}from"./C1H55nfk.js";let B=0;const $=1<<B++,p=1<<B++,T=1<<B++,R=1<<B++,D=1<<B++,V=1<<B++,x=Math.pow(2,B)-1,ur={[$]:"boolean",[p]:"number",[T]:"string",[R]:"color",[D]:"number[]",[V]:"size"},jr=Object.keys(ur).map(Number).sort(Fr);function Jr(r){return r in ur}function U(r){const e=[];for(const t of jr)j(r,t)&&e.push(ur[t]);return e.length===0?"untyped":e.length<3?e.join(" or "):e.slice(0,-1).join(", ")+", or "+e[e.length-1]}function j(r,e){return(r&e)===e}function F(r,e){return r===e}class b{constructor(e,t){if(!Jr(e))throw new Error(`literal expressions must have a specific type, got ${U(e)}`);this.type=e,this.value=t}}class Hr{constructor(e,t,...i){this.type=e,this.operator=t,this.args=i}}function $r(){return{variables:new Set,properties:new Set,featureId:!1,geometryType:!1,mapState:!1}}function A(r,e,t){switch(typeof r){case"boolean":{if(F(e,T))return new b(T,r?"true":"false");if(!j(e,$))throw new Error(`got a boolean, but expected ${U(e)}`);return new b($,r)}case"number":{if(F(e,V))return new b(V,br(r));if(F(e,$))return new b($,!!r);if(F(e,T))return new b(T,r.toString());if(!j(e,p))throw new Error(`got a number, but expected ${U(e)}`);return new b(p,r)}case"string":{if(F(e,R))return new b(R,yr(r));if(F(e,$))return new b($,!!r);if(!j(e,T))throw new Error(`got a string, but expected ${U(e)}`);return new b(T,r)}}if(!Array.isArray(r))throw new Error("expression must be an array or a primitive value");if(r.length===0)throw new Error("empty expression");if(typeof r[0]=="string")return ne(r,e,t);for(const i of r)if(typeof i!="number")throw new Error("expected an array of numbers");if(F(e,V)){if(r.length!==2)throw new Error(`expected an array of two values for a size, got ${r.length}`);return new b(V,r)}if(F(e,R)){if(r.length===3)return new b(R,[...r,1]);if(r.length===4)return new b(R,r);throw new Error(`expected an array of 3 or 4 values for a color, got ${r.length}`)}if(!j(e,D))throw new Error(`got an array of numbers, but expected ${U(e)}`);return new b(D,r)}const a={Get:"get",Var:"var",Concat:"concat",GeometryType:"geometry-type",LineMetric:"line-metric",Any:"any",All:"all",Not:"!",Resolution:"resolution",Zoom:"zoom",Time:"time",Equal:"==",NotEqual:"!=",GreaterThan:">",GreaterThanOrEqualTo:">=",LessThan:"<",LessThanOrEqualTo:"<=",Multiply:"*",Divide:"/",Add:"+",Subtract:"-",Clamp:"clamp",Mod:"%",Pow:"^",Abs:"abs",Floor:"floor",Ceil:"ceil",Round:"round",Sin:"sin",Cos:"cos",Atan:"atan",Sqrt:"sqrt",Match:"match",Between:"between",Interpolate:"interpolate",Coalesce:"coalesce",Case:"case",In:"in",Number:"number",String:"string",Array:"array",Color:"color",Id:"id",Band:"band",Palette:"palette",ToString:"to-string",Has:"has"},Zr={[a.Get]:h(g(1,1/0),fr),[a.Var]:h(g(1,1),Xr),[a.Has]:h(g(1,1/0),fr),[a.Id]:h(Yr,z),[a.Concat]:h(g(2,1/0),m(T)),[a.GeometryType]:h(Kr,z),[a.LineMetric]:h(z),[a.Resolution]:h(ir,z),[a.Zoom]:h(ir,z),[a.Time]:h(ir,z),[a.Any]:h(g(2,1/0),m($)),[a.All]:h(g(2,1/0),m($)),[a.Not]:h(g(1,1),m($)),[a.Equal]:h(g(2,2),m(x)),[a.NotEqual]:h(g(2,2),m(x)),[a.GreaterThan]:h(g(2,2),m(p)),[a.GreaterThanOrEqualTo]:h(g(2,2),m(p)),[a.LessThan]:h(g(2,2),m(p)),[a.LessThanOrEqualTo]:h(g(2,2),m(p)),[a.Multiply]:h(g(2,1/0),hr),[a.Coalesce]:h(g(2,1/0),hr),[a.Divide]:h(g(2,2),m(p)),[a.Add]:h(g(2,1/0),m(p)),[a.Subtract]:h(g(2,2),m(p)),[a.Clamp]:h(g(3,3),m(p)),[a.Mod]:h(g(2,2),m(p)),[a.Pow]:h(g(2,2),m(p)),[a.Abs]:h(g(1,1),m(p)),[a.Floor]:h(g(1,1),m(p)),[a.Ceil]:h(g(1,1),m(p)),[a.Round]:h(g(1,1),m(p)),[a.Sin]:h(g(1,1),m(p)),[a.Cos]:h(g(1,1),m(p)),[a.Atan]:h(g(1,2),m(p)),[a.Sqrt]:h(g(1,1),m(p)),[a.Match]:h(g(4,1/0),gr,Sr),[a.Between]:h(g(3,3),m(p)),[a.Interpolate]:h(g(6,1/0),gr,xr),[a.Case]:h(g(3,1/0),Qr,re),[a.In]:h(g(2,2),ee),[a.Number]:h(g(1,1/0),m(x)),[a.String]:h(g(1,1/0),m(x)),[a.Array]:h(g(1,1/0),m(p)),[a.Color]:h(g(1,4),m(p)),[a.Band]:h(g(1,3),m(p)),[a.Palette]:h(g(2,2),te),[a.ToString]:h(g(1,1),m($|p|T|R))};function fr(r,e,t){const i=r.length-1,o=new Array(i);for(let n=0;n<i;++n){const s=r[n+1];switch(typeof s){case"number":{o[n]=new b(p,s);break}case"string":{o[n]=new b(T,s);break}default:throw new Error(`expected a string key or numeric array index for a get operation, got ${s}`)}n===0&&t.properties.add(String(s))}return o}function Xr(r,e,t){const i=r[1];if(typeof i!="string")throw new Error("expected a string argument for var operation");return t.variables.add(i),[new b(T,i)]}function Yr(r,e,t){t.featureId=!0}function Kr(r,e,t){t.geometryType=!0}function ir(r,e,t){t.mapState=!0}function z(r,e,t){const i=r[0];if(r.length!==1)throw new Error(`expected no arguments for ${i} operation`);return[]}function g(r,e){return function(t,i,o){const n=t[0],s=t.length-1;if(r===e){if(s!==r){const u=r===1?"":"s";throw new Error(`expected ${r} argument${u} for ${n}, got ${s}`)}}else if(s<r||s>e){const u=e===1/0?`${r} or more`:`${r} to ${e}`;throw new Error(`expected ${u} arguments for ${n}, got ${s}`)}}}function hr(r,e,t){const i=r.length-1,o=new Array(i);for(let n=0;n<i;++n){const s=A(r[n+1],e,t);o[n]=s}return o}function m(r){return function(e,t,i){const o=e.length-1,n=new Array(o);for(let s=0;s<o;++s){const u=A(e[s+1],r,i);n[s]=u}return n}}function Qr(r,e,t){const i=r[0],o=r.length-1;if(o%2===0)throw new Error(`expected an odd number of arguments for ${i}, got ${o} instead`)}function gr(r,e,t){const i=r[0],o=r.length-1;if(o%2===1)throw new Error(`expected an even number of arguments for operation ${i}, got ${o} instead`)}function Sr(r,e,t){const i=r.length-1,o=T|p|$,n=A(r[1],o,t),s=A(r[r.length-1],e,t),u=new Array(i-2);for(let c=0;c<i-2;c+=2){try{const l=A(r[c+2],n.type,t);u[c]=l}catch(l){throw new Error(`failed to parse argument ${c+1} of match expression: ${l.message}`)}try{const l=A(r[c+3],s.type,t);u[c+1]=l}catch(l){throw new Error(`failed to parse argument ${c+2} of match expression: ${l.message}`)}}return[n,...u,s]}function xr(r,e,t){const i=r[1];let o;switch(i[0]){case"linear":o=1;break;case"exponential":const c=i[1];if(typeof c!="number"||c<=0)throw new Error(`expected a number base for exponential interpolation, got ${JSON.stringify(c)} instead`);o=c;break;default:throw new Error(`invalid interpolation type: ${JSON.stringify(i)}`)}const n=new b(p,o);let s;try{s=A(r[2],p,t)}catch(c){throw new Error(`failed to parse argument 1 in interpolate expression: ${c.message}`)}const u=new Array(r.length-3);for(let c=0;c<u.length;c+=2){try{const l=A(r[c+3],p,t);u[c]=l}catch(l){throw new Error(`failed to parse argument ${c+2} for interpolate expression: ${l.message}`)}try{const l=A(r[c+4],e,t);u[c+1]=l}catch(l){throw new Error(`failed to parse argument ${c+3} for interpolate expression: ${l.message}`)}}return[n,s,...u]}function re(r,e,t){const i=A(r[r.length-1],e,t),o=new Array(r.length-1);for(let n=0;n<o.length-1;n+=2){try{const s=A(r[n+1],$,t);o[n]=s}catch(s){throw new Error(`failed to parse argument ${n} of case expression: ${s.message}`)}try{const s=A(r[n+2],i.type,t);o[n+1]=s}catch(s){throw new Error(`failed to parse argument ${n+1} of case expression: ${s.message}`)}}return o[o.length-1]=i,o}function ee(r,e,t){let i=r[2];if(!Array.isArray(i))throw new Error('the second argument for the "in" operator must be an array');let o;if(typeof i[0]=="string"){if(i[0]!=="literal")throw new Error('for the "in" operator, a string array should be wrapped in a "literal" operator to disambiguate from expressions');if(!Array.isArray(i[1]))throw new Error('failed to parse "in" expression: the literal operator must be followed by an array');i=i[1],o=T}else o=p;const n=new Array(i.length);for(let u=0;u<n.length;u++)try{const c=A(i[u],o,t);n[u]=c}catch(c){throw new Error(`failed to parse haystack item ${u} for "in" expression: ${c.message}`)}return[A(r[1],o,t),...n]}function te(r,e,t){let i;try{i=A(r[1],p,t)}catch(s){throw new Error(`failed to parse first argument in palette expression: ${s.message}`)}const o=r[2];if(!Array.isArray(o))throw new Error("the second argument of palette must be an array");const n=new Array(o.length);for(let s=0;s<n.length;s++){let u;try{u=A(o[s],R,t)}catch(c){throw new Error(`failed to parse color at index ${s} in palette expression: ${c.message}`)}if(!(u instanceof b))throw new Error(`the palette color at index ${s} must be a literal value`);n[s]=u}return[i,...n]}function h(...r){return function(e,t,i){const o=e[0];let n;for(let s=0;s<r.length;s++){const u=r[s](e,t,i);if(s==r.length-1){if(!u)throw new Error("expected last argument validator to return the parsed args");n=u}}return new Hr(t,o,...n)}}function ne(r,e,t){const i=r[0],o=Zr[i];if(!o)throw new Error(`unknown operator: ${i}`);return o(r,e,t)}function Tr(r){if(!r)return"";const e=r.getType();switch(e){case"Point":case"LineString":case"Polygon":return e;case"MultiPoint":case"MultiLineString":case"MultiPolygon":return e.substring(5);case"Circle":return"Polygon";case"GeometryCollection":return Tr(r.getGeometries()[0]);default:return""}}function Cr(){return{variables:{},properties:{},resolution:NaN,featureId:null,geometryType:""}}function L(r,e,t){const i=A(r,e,t);return O(i)}function O(r,e){if(r instanceof b){if(r.type===R&&typeof r.value=="string"){const i=yr(r.value);return function(){return i}}return function(){return r.value}}const t=r.operator;switch(t){case a.Number:case a.String:case a.Coalesce:return oe(r);case a.Get:case a.Var:case a.Has:return ie(r);case a.Id:return i=>i.featureId;case a.GeometryType:return i=>i.geometryType;case a.Concat:{const i=r.args.map(o=>O(o));return o=>"".concat(...i.map(n=>n(o).toString()))}case a.Resolution:return i=>i.resolution;case a.Any:case a.All:case a.Between:case a.In:case a.Not:return ae(r);case a.Equal:case a.NotEqual:case a.LessThan:case a.LessThanOrEqualTo:case a.GreaterThan:case a.GreaterThanOrEqualTo:return se(r);case a.Multiply:case a.Divide:case a.Add:case a.Subtract:case a.Clamp:case a.Mod:case a.Pow:case a.Abs:case a.Floor:case a.Ceil:case a.Round:case a.Sin:case a.Cos:case a.Atan:case a.Sqrt:return ue(r);case a.Case:return ce(r);case a.Match:return le(r);case a.Interpolate:return fe(r);case a.ToString:return he(r);default:throw new Error(`Unsupported operator ${t}`)}}function oe(r,e){const t=r.operator,i=r.args.length,o=new Array(i);for(let n=0;n<i;++n)o[n]=O(r.args[n]);switch(t){case a.Coalesce:return n=>{for(let s=0;s<i;++s){const u=o[s](n);if(typeof u<"u"&&u!==null)return u}throw new Error("Expected one of the values to be non-null")};case a.Number:case a.String:return n=>{for(let s=0;s<i;++s){const u=o[s](n);if(typeof u===t)return u}throw new Error(`Expected one of the values to be a ${t}`)};default:throw new Error(`Unsupported assertion operator ${t}`)}}function ie(r,e){const i=r.args[0].value;switch(r.operator){case a.Get:return o=>{const n=r.args;let s=o.properties[i];for(let u=1,c=n.length;u<c;++u){const f=n[u].value;s=s[f]}return s};case a.Var:return o=>o.variables[i];case a.Has:return o=>{const n=r.args;if(!(i in o.properties))return!1;let s=o.properties[i];for(let u=1,c=n.length;u<c;++u){const f=n[u].value;if(!s||!Object.hasOwn(s,f))return!1;s=s[f]}return!0};default:throw new Error(`Unsupported accessor operator ${r.operator}`)}}function se(r,e){const t=r.operator,i=O(r.args[0]),o=O(r.args[1]);switch(t){case a.Equal:return n=>i(n)===o(n);case a.NotEqual:return n=>i(n)!==o(n);case a.LessThan:return n=>i(n)<o(n);case a.LessThanOrEqualTo:return n=>i(n)<=o(n);case a.GreaterThan:return n=>i(n)>o(n);case a.GreaterThanOrEqualTo:return n=>i(n)>=o(n);default:throw new Error(`Unsupported comparison operator ${t}`)}}function ae(r,e){const t=r.operator,i=r.args.length,o=new Array(i);for(let n=0;n<i;++n)o[n]=O(r.args[n]);switch(t){case a.Any:return n=>{for(let s=0;s<i;++s)if(o[s](n))return!0;return!1};case a.All:return n=>{for(let s=0;s<i;++s)if(!o[s](n))return!1;return!0};case a.Between:return n=>{const s=o[0](n),u=o[1](n),c=o[2](n);return s>=u&&s<=c};case a.In:return n=>{const s=o[0](n);for(let u=1;u<i;++u)if(s===o[u](n))return!0;return!1};case a.Not:return n=>!o[0](n);default:throw new Error(`Unsupported logical operator ${t}`)}}function ue(r,e){const t=r.operator,i=r.args.length,o=new Array(i);for(let n=0;n<i;++n)o[n]=O(r.args[n]);switch(t){case a.Multiply:return n=>{let s=1;for(let u=0;u<i;++u)s*=o[u](n);return s};case a.Divide:return n=>o[0](n)/o[1](n);case a.Add:return n=>{let s=0;for(let u=0;u<i;++u)s+=o[u](n);return s};case a.Subtract:return n=>o[0](n)-o[1](n);case a.Clamp:return n=>{const s=o[0](n),u=o[1](n);if(s<u)return u;const c=o[2](n);return s>c?c:s};case a.Mod:return n=>o[0](n)%o[1](n);case a.Pow:return n=>Math.pow(o[0](n),o[1](n));case a.Abs:return n=>Math.abs(o[0](n));case a.Floor:return n=>Math.floor(o[0](n));case a.Ceil:return n=>Math.ceil(o[0](n));case a.Round:return n=>Math.round(o[0](n));case a.Sin:return n=>Math.sin(o[0](n));case a.Cos:return n=>Math.cos(o[0](n));case a.Atan:return i===2?n=>Math.atan2(o[0](n),o[1](n)):n=>Math.atan(o[0](n));case a.Sqrt:return n=>Math.sqrt(o[0](n));default:throw new Error(`Unsupported numeric operator ${t}`)}}function ce(r,e){const t=r.args.length,i=new Array(t);for(let o=0;o<t;++o)i[o]=O(r.args[o]);return o=>{for(let n=0;n<t-1;n+=2)if(i[n](o))return i[n+1](o);return i[t-1](o)}}function le(r,e){const t=r.args.length,i=new Array(t);for(let o=0;o<t;++o)i[o]=O(r.args[o]);return o=>{const n=i[0](o);for(let s=1;s<t-1;s+=2)if(n===i[s](o))return i[s+1](o);return i[t-1](o)}}function fe(r,e){const t=r.args.length,i=new Array(t);for(let o=0;o<t;++o)i[o]=O(r.args[o]);return o=>{const n=i[0](o),s=i[1](o);let u,c;for(let l=2;l<t;l+=2){const f=i[l](o);let w=i[l+1](o);const d=Array.isArray(w);if(d&&(w=Lr(w)),f>=s)return l===2?w:d?ge(n,s,u,c,f,w):J(n,s,u,c,f,w);u=f,c=w}return c}}function he(r,e){const t=r.operator,i=r.args.length,o=new Array(i);for(let n=0;n<i;++n)o[n]=O(r.args[n]);switch(t){case a.ToString:return n=>{const s=o[0](n);return r.args[0].type===R?Nr(s):s.toString()};default:throw new Error(`Unsupported convert operator ${t}`)}}function J(r,e,t,i,o,n){const s=o-t;if(s===0)return i;const u=e-t,c=r===1?u/s:(Math.pow(r,u)-1)/(Math.pow(r,s)-1);return i+c*(n-i)}function ge(r,e,t,i,o,n){if(o-t===0)return i;const u=lr(i),c=lr(n);let l=c[2]-u[2];l>180?l-=360:l<-180&&(l+=360);const f=[J(r,e,t,u[0],o,c[0]),J(r,e,t,u[1],o,c[1]),u[2]+J(r,e,t,0,o,l),J(r,e,t,i[3],o,n[3])];return qr(f)}function pe(r){return!0}function we(r){const e=$r(),t=de(r,e),i=Cr();return function(o,n){if(i.properties=o.getPropertiesInternal(),i.resolution=n,e.featureId){const s=o.getId();s!==void 0?i.featureId=s:i.featureId=null}return e.geometryType&&(i.geometryType=Tr(o.getGeometry())),t(i)}}function pr(r){const e=$r(),t=r.length,i=new Array(t);for(let s=0;s<t;++s)i[s]=sr(r[s],e);const o=Cr(),n=new Array(t);return function(s,u){if(o.properties=s.getPropertiesInternal(),o.resolution=u,e.featureId){const l=s.getId();l!==void 0?o.featureId=l:o.featureId=null}let c=0;for(let l=0;l<t;++l){const f=i[l](o);f&&(n[c]=f,c+=1)}return n.length=c,n}}function de(r,e){const t=r.length,i=new Array(t);for(let o=0;o<t;++o){const n=r[o],s="filter"in n?L(n.filter,$,e):pe;let u;if(Array.isArray(n.style)){const c=n.style.length;u=new Array(c);for(let l=0;l<c;++l)u[l]=sr(n.style[l],e)}else u=[sr(n.style,e)];i[o]={filter:s,styles:u}}return function(o){const n=[];let s=!1;for(let u=0;u<t;++u){const c=i[u].filter;if(c(o)&&!(r[u].else&&s)){s=!0;for(const l of i[u].styles){const f=l(o);f&&n.push(f)}}}return n}}function sr(r,e){const t=H(r,"",e),i=Z(r,"",e),o=me(r,e),n=Ee(r,e),s=C(r,"z-index",e);if(!t&&!i&&!o&&!n&&!Dr(r))throw new Error("No fill, stroke, point, or text symbolizer properties in style: "+JSON.stringify(r));const u=new rr;return function(c){let l=!0;if(t){const f=t(c);f&&(l=!1),u.setFill(f)}if(i){const f=i(c);f&&(l=!1),u.setStroke(f)}if(o){const f=o(c);f&&(l=!1),u.setText(f)}if(n){const f=n(c);f&&(l=!1),u.setImage(f)}return s&&u.setZIndex(s(c)),l?null:u}}function H(r,e,t){let i;if(e+"fill-pattern-src"in r)i=Ae(r,e+"fill-",t);else{if(r[e+"fill-color"]==="none")return n=>null;i=cr(r,e+"fill-color",t)}if(!i)return null;const o=new Pr;return function(n){const s=i(n);return s===vr?null:(o.setColor(s),o)}}function Z(r,e,t){const i=C(r,e+"stroke-width",t),o=cr(r,e+"stroke-color",t);if(!i&&!o)return null;const n=N(r,e+"stroke-line-cap",t),s=N(r,e+"stroke-line-join",t),u=Ir(r,e+"stroke-line-dash",t),c=C(r,e+"stroke-line-dash-offset",t),l=C(r,e+"stroke-miter-limit",t),f=new _r;return function(w){if(o){const d=o(w);if(d===vr)return null;f.setColor(d)}if(i&&f.setWidth(i(w)),n){const d=n(w);if(d!=="butt"&&d!=="round"&&d!=="square")throw new Error("Expected butt, round, or square line cap");f.setLineCap(d)}if(s){const d=s(w);if(d!=="bevel"&&d!=="round"&&d!=="miter")throw new Error("Expected bevel, round, or miter line join");f.setLineJoin(d)}return u&&f.setLineDash(u(w)),c&&f.setLineDashOffset(c(w)),l&&f.setMiterLimit(l(w)),f}}function me(r,e){const t="text-",i=N(r,t+"value",e);if(!i)return null;const o=H(r,t,e),n=H(r,t+"background-",e),s=Z(r,t,e),u=Z(r,t+"background-",e),c=N(r,t+"font",e),l=C(r,t+"max-angle",e),f=C(r,t+"offset-x",e),w=C(r,t+"offset-y",e),d=_(r,t+"overflow",e),G=N(r,t+"placement",e),W=C(r,t+"repeat",e),P=nr(r,t+"scale",e),I=_(r,t+"rotate-with-view",e),k=C(r,t+"rotation",e),Y=N(r,t+"align",e),K=N(r,t+"justify",e),Q=N(r,t+"baseline",e),S=_(r,t+"keep-upright",e),M=Ir(r,t+"padding",e),q=or(r,t+"declutter-mode"),y=new Vr({declutterMode:q});return function(v){if(y.setText(i(v)),o&&y.setFill(o(v)),n&&y.setBackgroundFill(n(v)),s&&y.setStroke(s(v)),u&&y.setBackgroundStroke(u(v)),c&&y.setFont(c(v)),l&&y.setMaxAngle(l(v)),f&&y.setOffsetX(f(v)),w&&y.setOffsetY(w(v)),d&&y.setOverflow(d(v)),G){const E=G(v);if(E!=="point"&&E!=="line")throw new Error("Expected point or line for text-placement");y.setPlacement(E)}if(W&&y.setRepeat(W(v)),P&&y.setScale(P(v)),I&&y.setRotateWithView(I(v)),k&&y.setRotation(k(v)),Y){const E=Y(v);if(E!=="left"&&E!=="center"&&E!=="right"&&E!=="end"&&E!=="start")throw new Error("Expected left, right, center, start, or end for text-align");y.setTextAlign(E)}if(K){const E=K(v);if(E!=="left"&&E!=="right"&&E!=="center")throw new Error("Expected left, right, or center for text-justify");y.setJustify(E)}if(Q){const E=Q(v);if(E!=="bottom"&&E!=="top"&&E!=="middle"&&E!=="alphabetic"&&E!=="hanging")throw new Error("Expected bottom, top, middle, alphabetic, or hanging for text-baseline");y.setTextBaseline(E)}return M&&y.setPadding(M(v)),S&&y.setKeepUpright(S(v)),y}}function Ee(r,e){return"icon-src"in r?ye(r,e):"shape-points"in r?ve(r,e):"circle-radius"in r?be(r,e):null}function ye(r,e){const t="icon-",i=t+"src",o=kr(r[i],i),n=er(r,t+"anchor",e),s=nr(r,t+"scale",e),u=C(r,t+"opacity",e),c=er(r,t+"displacement",e),l=C(r,t+"rotation",e),f=_(r,t+"rotate-with-view",e),w=dr(r,t+"anchor-origin"),d=mr(r,t+"anchor-x-units"),G=mr(r,t+"anchor-y-units"),W=Ie(r,t+"color"),P=Te(r,t+"cross-origin"),I=Ce(r,t+"offset"),k=dr(r,t+"offset-origin"),Y=tr(r,t+"width"),K=tr(r,t+"height"),Q=$e(r,t+"size"),S=or(r,t+"declutter-mode"),M=new zr({src:o,anchorOrigin:w,anchorXUnits:d,anchorYUnits:G,color:W,crossOrigin:P,offset:I,offsetOrigin:k,height:K,width:Y,size:Q,declutterMode:S});return function(q){return u&&M.setOpacity(u(q)),c&&M.setDisplacement(c(q)),l&&M.setRotation(l(q)),f&&M.setRotateWithView(f(q)),s&&M.setScale(s(q)),n&&M.setAnchor(n(q)),M}}function ve(r,e){const t="shape-",i=t+"points",o=t+"radius",n=ar(r[i],i),s=ar(r[o],o),u=H(r,t,e),c=Z(r,t,e),l=nr(r,t+"scale",e),f=er(r,t+"displacement",e),w=C(r,t+"rotation",e),d=_(r,t+"rotate-with-view",e),G=tr(r,t+"radius2"),W=tr(r,t+"angle"),P=or(r,t+"declutter-mode"),I=new Br({points:n,radius:s,radius2:G,angle:W,declutterMode:P});return function(k){return u&&I.setFill(u(k)),c&&I.setStroke(c(k)),f&&I.setDisplacement(f(k)),w&&I.setRotation(w(k)),d&&I.setRotateWithView(d(k)),l&&I.setScale(l(k)),I}}function be(r,e){const t="circle-",i=H(r,t,e),o=Z(r,t,e),n=C(r,t+"radius",e),s=nr(r,t+"scale",e),u=er(r,t+"displacement",e),c=C(r,t+"rotation",e),l=_(r,t+"rotate-with-view",e),f=or(r,t+"declutter-mode"),w=new Gr({radius:5,declutterMode:f});return function(d){return n&&w.setRadius(n(d)),i&&w.setFill(i(d)),o&&w.setStroke(o(d)),u&&w.setDisplacement(u(d)),c&&w.setRotation(c(d)),l&&w.setRotateWithView(l(d)),s&&w.setScale(s(d)),w}}function C(r,e,t){if(!(e in r))return;const i=L(r[e],p,t);return function(o){return ar(i(o),e)}}function N(r,e,t){if(!(e in r))return null;const i=L(r[e],T,t);return function(o){return kr(i(o),e)}}function Ae(r,e,t){const i=N(r,e+"pattern-src",t),o=wr(r,e+"pattern-offset",t),n=wr(r,e+"pattern-size",t),s=cr(r,e+"color",t);return function(u){return{src:i(u),offset:o&&o(u),size:n&&n(u),color:s&&s(u)}}}function _(r,e,t){if(!(e in r))return null;const i=L(r[e],$,t);return function(o){const n=i(o);if(typeof n!="boolean")throw new Error(`Expected a boolean for ${e}`);return n}}function cr(r,e,t){if(!(e in r))return null;const i=L(r[e],R,t);return function(o){return Rr(i(o),e)}}function Ir(r,e,t){if(!(e in r))return null;const i=L(r[e],D,t);return function(o){return X(i(o),e)}}function er(r,e,t){if(!(e in r))return null;const i=L(r[e],D,t);return function(o){const n=X(i(o),e);if(n.length!==2)throw new Error(`Expected two numbers for ${e}`);return n}}function wr(r,e,t){if(!(e in r))return null;const i=L(r[e],D,t);return function(o){return Or(i(o),e)}}function nr(r,e,t){if(!(e in r))return null;const i=L(r[e],D|p,t);return function(o){return ke(i(o),e)}}function tr(r,e){const t=r[e];if(t!==void 0){if(typeof t!="number")throw new Error(`Expected a number for ${e}`);return t}}function $e(r,e){const t=r[e];if(t!==void 0){if(typeof t=="number")return br(t);if(!Array.isArray(t))throw new Error(`Expected a number or size array for ${e}`);if(t.length!==2||typeof t[0]!="number"||typeof t[1]!="number")throw new Error(`Expected a number or size array for ${e}`);return t}}function Te(r,e){const t=r[e];if(t!==void 0){if(typeof t!="string")throw new Error(`Expected a string for ${e}`);return t}}function dr(r,e){const t=r[e];if(t!==void 0){if(t!=="bottom-left"&&t!=="bottom-right"&&t!=="top-left"&&t!=="top-right")throw new Error(`Expected bottom-left, bottom-right, top-left, or top-right for ${e}`);return t}}function mr(r,e){const t=r[e];if(t!==void 0){if(t!=="pixels"&&t!=="fraction")throw new Error(`Expected pixels or fraction for ${e}`);return t}}function Ce(r,e){const t=r[e];if(t!==void 0)return X(t,e)}function or(r,e){const t=r[e];if(t!==void 0){if(typeof t!="string")throw new Error(`Expected a string for ${e}`);if(t!=="declutter"&&t!=="obstacle"&&t!=="none")throw new Error(`Expected declutter, obstacle, or none for ${e}`);return t}}function Ie(r,e){const t=r[e];if(t!==void 0)return Rr(t,e)}function X(r,e){if(!Array.isArray(r))throw new Error(`Expected an array for ${e}`);const t=r.length;for(let i=0;i<t;++i)if(typeof r[i]!="number")throw new Error(`Expected an array of numbers for ${e}`);return r}function kr(r,e){if(typeof r!="string")throw new Error(`Expected a string for ${e}`);return r}function ar(r,e){if(typeof r!="number")throw new Error(`Expected a number for ${e}`);return r}function Rr(r,e){if(typeof r=="string")return r;const t=X(r,e),i=t.length;if(i<3||i>4)throw new Error(`Expected a color with 3 or 4 values for ${e}`);return t}function Or(r,e){const t=X(r,e);if(t.length!==2)throw new Error(`Expected an array of two numbers for ${e}`);return t}function ke(r,e){return typeof r=="number"?r:Or(r,e)}const Er={RENDER_ORDER:"renderOrder"};class Pe extends Ur{constructor(e){e=e||{};const t=Object.assign({},e);delete t.style,delete t.renderBuffer,delete t.updateWhileAnimating,delete t.updateWhileInteracting,super(t),this.declutter_=e.declutter?String(e.declutter):void 0,this.renderBuffer_=e.renderBuffer!==void 0?e.renderBuffer:100,this.style_=null,this.styleFunction_=void 0,this.setStyle(e.style),this.updateWhileAnimating_=e.updateWhileAnimating!==void 0?e.updateWhileAnimating:!1,this.updateWhileInteracting_=e.updateWhileInteracting!==void 0?e.updateWhileInteracting:!1}getDeclutter(){return this.declutter_}getFeatures(e){return super.getFeatures(e)}getRenderBuffer(){return this.renderBuffer_}getRenderOrder(){return this.get(Er.RENDER_ORDER)}getStyle(){return this.style_}getStyleFunction(){return this.styleFunction_}getUpdateWhileAnimating(){return this.updateWhileAnimating_}getUpdateWhileInteracting(){return this.updateWhileInteracting_}renderDeclutter(e,t){const i=this.getDeclutter();i in e.declutter||(e.declutter[i]=new Mr(9)),this.getRenderer().renderDeclutter(e,t)}setRenderOrder(e){this.set(Er.RENDER_ORDER,e)}setStyle(e){this.style_=e===void 0?Ar:e;const t=Re(e);this.styleFunction_=e===null?void 0:Wr(t),this.changed()}setDeclutter(e){this.declutter_=e?String(e):void 0,this.changed()}}function Re(r){if(r===void 0)return Ar;if(!r)return null;if(typeof r=="function"||r instanceof rr)return r;if(!Array.isArray(r))return pr([r]);if(r.length===0)return[];const e=r.length,t=r[0];if(t instanceof rr){const o=new Array(e);for(let n=0;n<e;++n){const s=r[n];if(!(s instanceof rr))throw new Error("Expected a list of style instances");o[n]=s}return o}if("style"in t){const o=new Array(e);for(let n=0;n<e;++n){const s=r[n];if(!("style"in s))throw new Error("Expected a list of rules with a style property");o[n]=s}return we(o)}return pr(r)}export{Pe as B};
